# 스택의 구현 - 1차원 배열

* int 형의 1차원 배열 stack[MAX_STACK_SIZE]
* top : 가장 최근에 입력되었던 자료
* 가장 먼저 들어온 요소는 stack[0]에, 가장 최근에 들어온 요소는 stack[top]에 저장
* **top 변수는 스택이 비어 있으면 -1의 값을 갖는다.**

# 스택 연산 의사코드
>### 1. 스택의 is_empty 연산

>>스택이 비어 있는지 검사하기 위해 top을 -1과 비교한다.

```
is_empty(S):
	if top == -1
		then return TRUE
		else return FALSE
```

>### 2. 스택의 is_full 연산

>>스택이 가득 차 있는지 검사하기 위해 top을 (MAX_STACK_SIZE - 1)과 비교한다.

```
is_full(S):
	if top >= (MAX_STACK_SIZE - 1)
		then return TRUE
		else return FALSE
```

>### 3. 스택의 push 연산

>>스택이 가득 찼는지 검사한다. 가득 차 있지 않으면 먼저 top의 값을 증가하고 x를 stack[top]에 추가한다.

```
push(S,, x):
	if is_full(S)
		then error "overflow"
		else top <- top + 1
			 stack[top] <- x
```

>### 4. 스택의 pop 연산

>>스택이 비어 있는지 검사한다. 비어 있지 않으면 top이 가리키는 값을 반환하고 top을 하나 감소시킨다.

```
pop(S, x) ;
	if is_empty(S)
		then error "underflow"
		else e <- stack[top]
			 top <- top + 1
			 return e
```

# 스택의 구현
### 1. 전역 변수로 구현하는 방법
* 1차원 배열과 top 변수 모두 전역 변수로 구현한다. -> 함수의 매개 변수로 전달할 필요가 없다.
* 스택에 저장되는 데이터의 타입은 typedef을 이용하여 element로 정의되었다.
* pop 연산 - 먼저 top이 가리키는 위치에서 데이터를 꺼내온 다음, top을 하나 감소시킨다.
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_STACK_SIZE 100		//스택의 최대크기
typedef int element;			//데이터의 자료형
element stack[MAX_STACK_SIZE];	//1차원 배열
int top = -1;

//공백 상태 검출 함수
int is_empty() {
	return (top == -1);
}

//포화 상태 검출 함수
int is_full() {
	return (top == (MAX_STACK_SIZE - 1));
}

//삽입 함수
void push(element item) {
	if (is_full()) {
		fprintf(stderr, "스택 포화 에러\n");
		//stderr로 출력되는 메시지는 버퍼링없이 즉시 출력된다. 따라서 문제가 생겼을 경우 즉시 출력된다.
		return;
	}
	else stack[++top] = item; //++top 후 item 추가
}

//삭제 함수
element pop() {
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return stack[top--]; //stack[top] 반환 후 top--
}

//피크 함수
element peek() {
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return stack[top]; //top 원소 반환
}

int main(void) {
	push(1);
	push(2);
	push(3);
	printf("%d\n", pop()); //3
	printf("%d\n", pop()); //2
	printf("%d\n", pop()); //1
	return 0;
}
```

### 2. 스택의 요소를 구조체로 하기
* 스택에 저장되어야 하는 값이 정수나 문자가 아니고 복잡한 구조를 갖는다면 구조체를 사용한다.
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_STACK_SIZE 100		//스택의 최대크기
#define MAX_STRING 100			//문자열 최대크기

//스택 구조체
typedef struct {
	int student_no; //학번
	char name[MAX_STRING]; //이름
	char address[MAX_STRING]; //주소
}element;

//-----------------------------------위와 같다--------
element stack[MAX_STACK_SIZE];
int top = -1;

//공백 상태 검출 함수
int is_empty() {
	return (top == -1);
}

//포화 상태 검출 함수
int is_full() {
	return (top == (MAX_STACK_SIZE - 1));
}

//삽입 함수
void push(element item) {
	if (is_full()) {
		fprintf(stderr, "스택 포화 에러\n");
		return;
	}
	else stack[++top] = item; //++top 후 item 추가
}

//삭제 함수
element pop() {
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return stack[top--]; //stack[top] 반환 후 top--
}

//피크 함수
element peek() {
	if (is_empty()) {
		fprintf(stderr, "스택 공백 에러\n");
		exit(1);
	}
	else return stack[top]; //top 원소 반환
}

//-----------------------------------위와 같다--------

int main(void) {
	element ie = { 20190001, "Hong", "Seoul" };
	element oe;

	push(ie); //스택에 ie 추가
	oe = pop(); //pop한 데이터들 oe에 넣기

	printf("학번 : %d\n", oe.student_no); //20190001
	printf("이름 : %s\n", oe.name); //Hong
	printf("주소 : %s\n", oe.address); //Seoul

	return 0;
}

```

### 3. 관련된 데이터를 함수의 매개변수로 전달하는 방법

 
### 4. 스택을 동적 메모리 할당으로 생성하는 방법